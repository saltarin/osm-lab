const { dijkstra, dijkstraShortestPath, INFINITE } = require('./dijkstra');
const Graph = require('./Graph');
const Node = require('./Node');

describe('dijkstra', () => {
    it('default', () => {
        const graph = new Graph();
        const nodeA = new Node('A');
        const nodeB = new Node('B');
        const nodeC = new Node('C');
        const nodeD = new Node('D');
        const nodeE = new Node('E');
        const nodeF = new Node('F');
        graph.addNode(nodeA);
        graph.addNode(nodeB);
        graph.addNode(nodeC);
        graph.addNode(nodeD);
        graph.addNode(nodeE);
        graph.addNode(nodeF);
        graph.addWeight(nodeA.key, nodeB.key, 3);
        graph.addWeight(nodeA.key, nodeC.key, 1);
        graph.addWeight(nodeA.key, nodeE.key, 2);
        graph.addWeight(nodeB.key, nodeD.key, 3);
        graph.addWeight(nodeC.key, nodeD.key, 10);
        graph.addWeight(nodeE.key, nodeF.key, 2);
        graph.addWeight(nodeF.key, nodeD.key, 1);
        graph.addWeight(nodeC.key, nodeF.key, 5);
        const source = nodeA.key;
        const { distance, previusNode, iteration } = dijkstra(graph, source);
        const minDistanceToNodeD = distance[nodeD.key];
        expect(minDistanceToNodeD).toEqual(5);
    });

    it('default', () => {
        const graph = new Graph();
        const nodeA = new Node('A');
        const nodeB = new Node('B');
        const nodeC = new Node('C');
        const nodeD = new Node('D');
        const nodeE = new Node('E');
        const nodeF = new Node('F');
        const nodeG = new Node('G');
        const nodeH = new Node('H');
        graph.addNode(nodeA);
        graph.addNode(nodeB);
        graph.addNode(nodeC);
        graph.addNode(nodeD);
        graph.addNode(nodeE);
        graph.addNode(nodeF);
        graph.addNode(nodeG);
        graph.addNode(nodeH);
        graph.addWeight(nodeA.key, nodeB.key, 3);
        graph.addWeight(nodeA.key, nodeC.key, 1);
        graph.addWeight(nodeA.key, nodeE.key, 2);
        graph.addWeight(nodeB.key, nodeD.key, 3);
        graph.addWeight(nodeC.key, nodeD.key, 10);
        graph.addWeight(nodeE.key, nodeF.key, 2);
        graph.addWeight(nodeF.key, nodeD.key, 1);
        graph.addWeight(nodeC.key, nodeF.key, 5);
        graph.addWeight(nodeD.key, nodeG.key, 5);
        graph.addWeight(nodeD.key, nodeH.key, 5);
        const source = nodeA.key;
        const target = nodeD.key;
        const { distance, previusNode, iteration } = dijkstraShortestPath(graph, source, target);
        const minDistanceToNodeD = distance[nodeD.key];
        const minDistanceToNotSearched = distance[nodeG.key];
        expect(minDistanceToNodeD).toEqual(5);
        expect(minDistanceToNotSearched).toEqual(INFINITE);
    });
});